<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipeline - Admin Dashboard</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { margin-bottom: 20px; color: #333; }
        h2 { margin: 20px 0 10px; color: #555; font-size: 1.2em; }
        .card { background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; }
        input[type="text"], input[type="number"] { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 14px; }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        table { width: 100%; border-collapse: collapse; }
        th, td { text-align: left; padding: 12px; border-bottom: 1px solid #eee; }
        th { background: #f8f9fa; font-weight: 600; }
        .status { padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 500; }
        .status.healthy, .status.completed { background: #d4edda; color: #155724; }
        .status.unhealthy, .status.failed { background: #f8d7da; color: #721c24; }
        .status.created { background: #e2e3e5; color: #383d41; }
        .status.in_progress { background: #cce5ff; color: #004085; }
        .status.purged { background: #f5f5f5; color: #6c757d; }
        .status.cancelled { background: #fff3cd; color: #856404; }
        .btn-danger { background: #dc3545; margin-left: 5px; }
        .btn-danger:hover { background: #c82333; }
        .btn-small { padding: 5px 10px; font-size: 12px; }
        .progress-bar { width: 100%; height: 20px; background: #e9ecef; border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: #28a745; transition: width 0.3s; }
        .refresh-btn { background: #6c757d; margin-left: 10px; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .error { color: #dc3545; margin-top: 10px; }
        .success { color: #28a745; margin-top: 10px; }
        .throughput { color: #6c757d; font-size: 12px; }
        .job-summary { margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px; }
        .job-summary span { margin-right: 20px; }

        /* Tabs */
        .tabs { display: flex; border-bottom: 2px solid #dee2e6; margin-bottom: 20px; }
        .tab { padding: 12px 24px; cursor: pointer; border: none; background: none; font-size: 16px; font-weight: 500; color: #6c757d; border-bottom: 2px solid transparent; margin-bottom: -2px; }
        .tab:hover { color: #333; }
        .tab.active { color: #007bff; border-bottom-color: #007bff; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-badge { background: #6c757d; color: white; padding: 2px 8px; border-radius: 10px; font-size: 12px; margin-left: 8px; }
        .tab.active .tab-badge { background: #007bff; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Pipeline Admin Dashboard</h1>
            <button class="refresh-btn" onclick="refreshAll()">Refresh All</button>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('jobs')">
                Jobs <span class="tab-badge" id="jobsCount">0</span>
            </button>
            <button class="tab" onclick="switchTab('servers')">
                Servers <span class="tab-badge" id="serversCount">0</span>
            </button>
        </div>

        <!-- Jobs Tab -->
        <div id="jobs-tab" class="tab-content active">
            <div class="card">
                <h2>Create New Deployment Job</h2>
                <form id="createJobForm">
                    <div class="form-group">
                        <label for="gcsManifestPath">GCS Manifest Path</label>
                        <input type="text" id="gcsManifestPath" placeholder="gs://bucket/path/model.manifest" required>
                        <small style="color: #666; display: block; margin-top: 4px;">Shards are resolved relative to the manifest directory</small>
                    </div>
                    <button type="submit">Create Job</button>
                    <div id="createJobResult"></div>
                </form>
            </div>

            <div class="card">
                <h2>Deployment Jobs</h2>
                <table id="jobsTable">
                    <thead>
                        <tr>
                            <th>Job ID</th>
                            <th>GCS Path</th>
                            <th>Total Size</th>
                            <th>Shards</th>
                            <th>Status</th>
                            <th>Created</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <div class="card" id="jobDetailsCard" style="display: none;">
                <h2>Job Details: <span id="selectedJobId"></span></h2>
                <div class="job-summary" id="jobSummary"></div>
                <table id="jobProgressTable">
                    <thead>
                        <tr>
                            <th>Server Address</th>
                            <th>Server</th>
                            <th>Upstream</th>
                            <th>Task</th>
                            <th>Progress</th>
                            <th>Throughput</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- Servers Tab -->
        <div id="servers-tab" class="tab-content">
            <div class="card">
                <h2>Servers</h2>
                <table id="serversTable">
                    <thead>
                        <tr>
                            <th>Server Address</th>
                            <th>Status</th>
                            <th>Last Heartbeat</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let currentJobId = null;

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`${tabName}-tab`).classList.add('active');

            // Update URL
            const url = new URL(window.location);
            url.searchParams.set('tab', tabName);
            window.history.replaceState({}, '', url);
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatThroughput(bytesPerSec) {
            if (bytesPerSec <= 0) return '-';
            return formatBytes(bytesPerSec) + '/s';
        }

        function formatElapsed(startTime, endTime, status) {
            const finalStates = ['completed', 'failed', 'cancelled', 'purged'];
            const end = finalStates.includes(status) && endTime ? new Date(endTime).getTime() : Date.now();
            const elapsed = Math.floor((end - new Date(startTime).getTime()) / 1000);
            const hours = Math.floor(elapsed / 3600);
            const minutes = Math.floor((elapsed % 3600) / 60);
            const seconds = elapsed % 60;
            if (hours > 0) {
                return `${hours}h ${minutes}m ${seconds}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            }
            return `${seconds}s`;
        }

        async function fetchServers() {
            try {
                const res = await fetch('/admin/servers');
                const servers = await res.json();
                document.getElementById('serversCount').textContent = servers.length;
                const tbody = document.querySelector('#serversTable tbody');
                tbody.innerHTML = servers.map(s => `
                    <tr>
                        <td>${s.serverAddress}</td>
                        <td><span class="status ${s.status}">${s.status}</span></td>
                        <td>${new Date(s.lastHeartbeat).toLocaleString()}</td>
                    </tr>
                `).join('');
            } catch (e) {
                console.error('Failed to fetch servers:', e);
            }
        }

        async function fetchJobs() {
            try {
                const res = await fetch('/admin/jobs');
                const jobs = await res.json();
                document.getElementById('jobsCount').textContent = jobs.length;
                const tbody = document.querySelector('#jobsTable tbody');
                tbody.innerHTML = jobs.map(j => {
                    const isSelected = j.deploymentJobId === currentJobId;
                    const canCancel = j.status === 'created' || j.status === 'in_progress';
                    const canPurge = j.status === 'completed' || j.status === 'failed' || j.status === 'cancelled';
                    return `
                        <tr style="${isSelected ? 'background: #e3f2fd;' : ''}">
                            <td>${j.deploymentJobId.substring(0, 8)}...</td>
                            <td>${j.gcsManifestPath}</td>
                            <td>${formatBytes(j.totalSize)}</td>
                            <td>${j.totalShards}</td>
                            <td><span class="status ${j.status}">${j.status}</span></td>
                            <td>${new Date(j.createdAt).toLocaleString()}</td>
                            <td>
                                <button class="btn-small" onclick="viewJobDetails('${j.deploymentJobId}')">${isSelected ? 'Viewing' : 'View'}</button>
                                ${canCancel ? `<button class="btn-small btn-danger" onclick="cancelJob('${j.deploymentJobId}')">Cancel</button>` : ''}
                                ${canPurge ? `<button class="btn-small btn-danger" onclick="purgeJob('${j.deploymentJobId}')">Purge</button>` : ''}
                            </td>
                        </tr>
                    `;
                }).join('');
            } catch (e) {
                console.error('Failed to fetch jobs:', e);
            }
        }

        async function viewJobDetails(jobId) {
            currentJobId = jobId;

            // Update URL without reloading
            const url = new URL(window.location);
            url.searchParams.set('job', jobId);
            window.history.pushState({}, '', url);

            await refreshJobDetails();
            fetchJobs(); // Refresh to show selection
        }

        async function cancelJob(jobId) {
            if (!confirm('Are you sure you want to cancel this job? Servers will stop downloading.')) {
                return;
            }

            try {
                const res = await fetch(`/admin/jobs/cancel/${jobId}`, { method: 'POST' });
                if (res.ok) {
                    fetchJobs();
                    refreshJobDetails();
                } else {
                    alert('Failed to cancel job: ' + await res.text());
                }
            } catch (e) {
                alert('Failed to cancel job: ' + e.message);
            }
        }

        async function purgeJob(jobId) {
            if (!confirm('Are you sure you want to purge this job? This will delete all shard data from servers.')) {
                return;
            }

            try {
                const res = await fetch(`/admin/jobs/purge/${jobId}`, { method: 'POST' });
                if (res.ok) {
                    // Clear selection if we purged the current job
                    if (currentJobId === jobId) {
                        currentJobId = null;
                        document.getElementById('jobDetailsCard').style.display = 'none';
                    }
                    fetchJobs();
                } else {
                    alert('Failed to purge job: ' + await res.text());
                }
            } catch (e) {
                alert('Failed to purge job: ' + e.message);
            }
        }

        async function refreshJobDetails() {
            if (!currentJobId) return;

            try {
                const res = await fetch(`/admin/jobs/${currentJobId}`);
                const details = await res.json();

                document.getElementById('jobDetailsCard').style.display = 'block';

                const totalShards = details.job.totalShards;
                const totalSize = details.job.totalSize;
                const shardSize = details.job.shardSize;
                const tbody = document.querySelector('#jobProgressTable tbody');

                // Calculate overall progress
                const totalShardsCompleted = details.serverProgress.reduce((sum, p) => sum + p.lastShardIdCompleted + 1, 0);
                const totalExpectedShards = details.serverProgress.length * totalShards;
                const overallProgress = totalExpectedShards > 0 ? (totalShardsCompleted / totalExpectedShards * 100).toFixed(1) : 0;

                // Calculate total bytes transferred
                const totalBytesTransferred = details.serverProgress.reduce((sum, p) => {
                    const shardsComplete = p.lastShardIdCompleted + 1;
                    return sum + (shardsComplete * shardSize);
                }, 0);
                const totalExpectedBytes = details.serverProgress.length * totalSize;

                document.getElementById('selectedJobId').textContent =
                    `${currentJobId.substring(0, 8)}... (Overall: ${overallProgress}%)`;

                // Calculate average progress across all servers
                const serverCount = details.serverProgress.length;
                const avgBytesComplete = serverCount > 0
                    ? details.serverProgress.reduce((sum, p) => {
                        const shardsComplete = p.lastShardIdCompleted + 1;
                        return sum + Math.min(shardsComplete * shardSize, totalSize);
                    }, 0) / serverCount
                    : 0;
                const avgProgress = totalSize > 0 ? (avgBytesComplete / totalSize * 100).toFixed(1) : 0;

                document.getElementById('jobSummary').innerHTML = `
                    <span><strong>Elapsed:</strong> ${formatElapsed(details.job.createdAt, details.job.updatedAt, details.job.status)}</span>
                    <span><strong>Total Size:</strong> ${formatBytes(totalSize)}</span>
                    <span><strong>Shard Size:</strong> ${formatBytes(shardSize)}</span>
                    <span><strong>Shards:</strong> ${totalShards}</span>
                    <span><strong>Avg Progress:</strong> ${formatBytes(avgBytesComplete)} / ${formatBytes(totalSize)} (${avgProgress}%)</span>
                `;

                // Sort by upstream (GCS first, then peers in order by address)
                details.serverProgress.sort((a, b) => {
                    const ua = a.upstream || '';
                    const ub = b.upstream || '';
                    const aIsGcs = ua.startsWith('GCS');
                    const bIsGcs = ub.startsWith('GCS');
                    // GCS first
                    if (aIsGcs && !bIsGcs) return -1;
                    if (!aIsGcs && bIsGcs) return 1;
                    return ua - ub;
                });

                tbody.innerHTML = details.serverProgress.map(p => {
                    const shardsComplete = p.lastShardIdCompleted + 1;
                    // Calculate overall progress including current shard progress
                    let effectiveProgress = shardsComplete;
                    if (p.currentShardId != null && p.currentShardProgressPct != null) {
                        effectiveProgress = shardsComplete + (p.currentShardProgressPct / 100);
                    }
                    const progress = totalShards > 0 ? (effectiveProgress / totalShards * 100).toFixed(1) : 0;
                    const bytesComplete = Math.min(effectiveProgress * shardSize, totalSize);

                    // Use server-reported throughput
                    const throughput = p.throughputBps ? formatThroughput(p.throughputBps) : '-';

                    // Show current shard being worked on
                    let currentShardInfo = '';
                    if (p.currentShardId != null && p.currentShardProgressPct != null) {
                        currentShardInfo = ` (shard ${p.currentShardId}: ${p.currentShardProgressPct.toFixed(0)}%)`;
                    }

                    return `
                        <tr>
                            <td>${p.serverAddress}</td>
                            <td><span class="status ${p.serverStatus}">${p.serverStatus}</span></td>
                            <td>${p.upstream || '-'}</td>
                            <td><span class="status ${p.status}">${p.status}</span></td>
                            <td>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${progress}%"></div>
                                </div>
                                ${formatBytes(bytesComplete)} / ${formatBytes(totalSize)} (${progress}%)<br>
                                <span style="color: #6c757d; font-size: 12px;">${shardsComplete} / ${totalShards} shards${currentShardInfo}</span>
                            </td>
                            <td class="throughput">${throughput}</td>
                        </tr>
                    `;
                }).join('');
            } catch (e) {
                console.error('Failed to fetch job details:', e);
            }
        }

        document.getElementById('createJobForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const resultDiv = document.getElementById('createJobResult');

            try {
                const res = await fetch('/admin/jobs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gcsManifestPath: document.getElementById('gcsManifestPath').value
                    })
                });

                if (res.ok) {
                    const data = await res.json();
                    resultDiv.innerHTML = `<span class="success">Job created: ${data.deploymentJobId}</span>`;
                    document.getElementById('createJobForm').reset();
                    fetchJobs();
                    // Auto-select the new job
                    viewJobDetails(data.deploymentJobId);
                } else {
                    resultDiv.innerHTML = `<span class="error">Error: ${await res.text()}</span>`;
                }
            } catch (e) {
                resultDiv.innerHTML = `<span class="error">Error: ${e.message}</span>`;
            }
        });

        function refreshAll() {
            fetchServers();
            fetchJobs();
            refreshJobDetails();
        }

        // Check URL for parameters on load
        function initFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const jobId = params.get('job');
            const tab = params.get('tab');

            if (jobId) {
                currentJobId = jobId;
            }
            if (tab && (tab === 'jobs' || tab === 'servers')) {
                switchTab(tab);
            }
        }

        // Initial load
        initFromUrl();
        refreshAll();

        // Auto-refresh every 2 seconds
        setInterval(refreshAll, 2000);
    </script>
</body>
</html>
